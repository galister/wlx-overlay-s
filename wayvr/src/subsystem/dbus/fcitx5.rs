// This code was autogenerated with `dbus-codegen-rust -g -m None -d org.fcitx.Fcitx5 -p /controller`, see https://github.com/diwic/dbus-rs
use dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus::blocking;

pub trait OrgFreedesktopDBusIntrospectable {
    fn introspect(&self) -> Result<String, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target = T>>
    OrgFreedesktopDBusIntrospectable for blocking::Proxy<'a, C>
{
    fn introspect(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.DBus.Introspectable", "Introspect", ())
            .and_then(|r: (String,)| Ok(r.0))
    }
}

pub trait OrgFcitxFcitxController1 {
    fn activate(&self) -> Result<(), dbus::Error>;
    fn add_input_method_group(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn addon_for_im(&self, arg0: &str) -> Result<String, dbus::Error>;
    fn available_input_methods(
        &self,
    ) -> Result<Vec<(String, String, String, String, String, String, bool)>, dbus::Error>;
    fn available_keyboard_layouts(
        &self,
    ) -> Result<
        Vec<(
            String,
            String,
            Vec<String>,
            Vec<(String, String, Vec<String>)>,
        )>,
        dbus::Error,
    >;
    fn can_restart(&self) -> Result<bool, dbus::Error>;
    fn check_update(&self) -> Result<bool, dbus::Error>;
    fn configure(&self) -> Result<(), dbus::Error>;
    fn configure_addon(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn configure_im(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn current_input_method(&self) -> Result<String, dbus::Error>;
    fn current_input_method_group(&self) -> Result<String, dbus::Error>;
    fn current_input_method_info(
        &self,
    ) -> Result<
        (
            String,
            String,
            String,
            String,
            String,
            String,
            String,
            bool,
            String,
            arg::PropMap,
        ),
        dbus::Error,
    >;
    fn current_ui(&self) -> Result<String, dbus::Error>;
    fn deactivate(&self) -> Result<(), dbus::Error>;
    fn debug_info(&self) -> Result<String, dbus::Error>;
    fn exit(&self) -> Result<(), dbus::Error>;
    fn full_input_method_group_info(
        &self,
        arg0: &str,
    ) -> Result<
        (
            String,
            String,
            String,
            arg::PropMap,
            Vec<(
                String,
                String,
                String,
                String,
                String,
                String,
                String,
                bool,
                String,
                arg::PropMap,
            )>,
        ),
        dbus::Error,
    >;
    fn get_addons(&self) -> Result<Vec<(String, String, String, i32, bool, bool)>, dbus::Error>;
    fn get_addons_v2(
        &self,
    ) -> Result<
        Vec<(
            String,
            String,
            String,
            i32,
            bool,
            bool,
            bool,
            Vec<String>,
            Vec<String>,
        )>,
        dbus::Error,
    >;
    fn get_config<R0: for<'b> arg::Get<'b> + 'static>(
        &self,
        arg0: &str,
    ) -> Result<
        (
            R0,
            Vec<(
                String,
                Vec<(
                    String,
                    String,
                    String,
                    arg::Variant<Box<dyn arg::RefArg + 'static>>,
                    arg::PropMap,
                )>,
            )>,
        ),
        dbus::Error,
    >;
    fn input_method_group_info(
        &self,
        arg0: &str,
    ) -> Result<(String, Vec<(String, String)>), dbus::Error>;
    fn input_method_groups(&self) -> Result<Vec<String>, dbus::Error>;
    fn open_wayland_connection(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn open_wayland_connection_socket(&self, arg0: arg::OwnedFd) -> Result<(), dbus::Error>;
    fn open_x11_connection(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn refresh(&self) -> Result<(), dbus::Error>;
    fn reload_addon_config(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn reload_config(&self) -> Result<(), dbus::Error>;
    fn remove_input_method_group(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn reopen_wayland_connection_socket(
        &self,
        arg0: &str,
        arg1: arg::OwnedFd,
    ) -> Result<(), dbus::Error>;
    fn reset_imlist(&self) -> Result<(), dbus::Error>;
    fn restart(&self) -> Result<(), dbus::Error>;
    fn save(&self) -> Result<(), dbus::Error>;
    fn set_addons_state(&self, arg0: Vec<(&str, bool)>) -> Result<(), dbus::Error>;
    fn set_config<I1: arg::Arg + arg::Append>(
        &self,
        arg0: &str,
        arg1: I1,
    ) -> Result<(), dbus::Error>;
    fn set_current_im(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn set_input_method_group_info(
        &self,
        arg0: &str,
        arg1: &str,
        arg2: Vec<(&str, &str)>,
    ) -> Result<(), dbus::Error>;
    fn set_log_rule(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn state(&self) -> Result<i32, dbus::Error>;
    fn switch_input_method_group(&self, arg0: &str) -> Result<(), dbus::Error>;
    fn toggle(&self) -> Result<(), dbus::Error>;
}

#[derive(Debug)]
pub struct OrgFcitxFcitxController1InputMethodGroupsChanged {}

impl arg::AppendAll for OrgFcitxFcitxController1InputMethodGroupsChanged {
    fn append(&self, _: &mut arg::IterAppend) {}
}

impl arg::ReadAll for OrgFcitxFcitxController1InputMethodGroupsChanged {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFcitxFcitxController1InputMethodGroupsChanged {})
    }
}

impl dbus::message::SignalArgs for OrgFcitxFcitxController1InputMethodGroupsChanged {
    const NAME: &'static str = "InputMethodGroupsChanged";
    const INTERFACE: &'static str = "org.fcitx.Fcitx.Controller1";
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target = T>> OrgFcitxFcitxController1
    for blocking::Proxy<'a, C>
{
    fn activate(&self) -> Result<(), dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "Activate", ())
    }

    fn add_input_method_group(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call(
            "org.fcitx.Fcitx.Controller1",
            "AddInputMethodGroup",
            (arg0,),
        )
    }

    fn addon_for_im(&self, arg0: &str) -> Result<String, dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "AddonForIM", (arg0,))
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn available_input_methods(
        &self,
    ) -> Result<Vec<(String, String, String, String, String, String, bool)>, dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "AvailableInputMethods", ())
            .and_then(|r: (Vec<(String, String, String, String, String, String, bool)>,)| Ok(r.0))
    }

    fn available_keyboard_layouts(
        &self,
    ) -> Result<
        Vec<(
            String,
            String,
            Vec<String>,
            Vec<(String, String, Vec<String>)>,
        )>,
        dbus::Error,
    > {
        self.method_call(
            "org.fcitx.Fcitx.Controller1",
            "AvailableKeyboardLayouts",
            (),
        )
        .and_then(
            |r: (
                Vec<(
                    String,
                    String,
                    Vec<String>,
                    Vec<(String, String, Vec<String>)>,
                )>,
            )| Ok(r.0),
        )
    }

    fn can_restart(&self) -> Result<bool, dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "CanRestart", ())
            .and_then(|r: (bool,)| Ok(r.0))
    }

    fn check_update(&self) -> Result<bool, dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "CheckUpdate", ())
            .and_then(|r: (bool,)| Ok(r.0))
    }

    fn configure(&self) -> Result<(), dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "Configure", ())
    }

    fn configure_addon(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "ConfigureAddon", (arg0,))
    }

    fn configure_im(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "ConfigureIM", (arg0,))
    }

    fn current_input_method(&self) -> Result<String, dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "CurrentInputMethod", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn current_input_method_group(&self) -> Result<String, dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "CurrentInputMethodGroup", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn current_input_method_info(
        &self,
    ) -> Result<
        (
            String,
            String,
            String,
            String,
            String,
            String,
            String,
            bool,
            String,
            arg::PropMap,
        ),
        dbus::Error,
    > {
        self.method_call("org.fcitx.Fcitx.Controller1", "CurrentInputMethodInfo", ())
    }

    fn current_ui(&self) -> Result<String, dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "CurrentUI", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn deactivate(&self) -> Result<(), dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "Deactivate", ())
    }

    fn debug_info(&self) -> Result<String, dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "DebugInfo", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn exit(&self) -> Result<(), dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "Exit", ())
    }

    fn full_input_method_group_info(
        &self,
        arg0: &str,
    ) -> Result<
        (
            String,
            String,
            String,
            arg::PropMap,
            Vec<(
                String,
                String,
                String,
                String,
                String,
                String,
                String,
                bool,
                String,
                arg::PropMap,
            )>,
        ),
        dbus::Error,
    > {
        self.method_call(
            "org.fcitx.Fcitx.Controller1",
            "FullInputMethodGroupInfo",
            (arg0,),
        )
    }

    fn get_addons(&self) -> Result<Vec<(String, String, String, i32, bool, bool)>, dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "GetAddons", ())
            .and_then(|r: (Vec<(String, String, String, i32, bool, bool)>,)| Ok(r.0))
    }

    fn get_addons_v2(
        &self,
    ) -> Result<
        Vec<(
            String,
            String,
            String,
            i32,
            bool,
            bool,
            bool,
            Vec<String>,
            Vec<String>,
        )>,
        dbus::Error,
    > {
        self.method_call("org.fcitx.Fcitx.Controller1", "GetAddonsV2", ())
            .and_then(
                |r: (
                    Vec<(
                        String,
                        String,
                        String,
                        i32,
                        bool,
                        bool,
                        bool,
                        Vec<String>,
                        Vec<String>,
                    )>,
                )| Ok(r.0),
            )
    }

    fn get_config<R0: for<'b> arg::Get<'b> + 'static>(
        &self,
        arg0: &str,
    ) -> Result<
        (
            R0,
            Vec<(
                String,
                Vec<(
                    String,
                    String,
                    String,
                    arg::Variant<Box<dyn arg::RefArg + 'static>>,
                    arg::PropMap,
                )>,
            )>,
        ),
        dbus::Error,
    > {
        self.method_call("org.fcitx.Fcitx.Controller1", "GetConfig", (arg0,))
            .and_then(
                |r: (
                    arg::Variant<R0>,
                    Vec<(
                        String,
                        Vec<(
                            String,
                            String,
                            String,
                            arg::Variant<Box<dyn arg::RefArg + 'static>>,
                            arg::PropMap,
                        )>,
                    )>,
                )| Ok(((r.0).0, r.1)),
            )
    }

    fn input_method_group_info(
        &self,
        arg0: &str,
    ) -> Result<(String, Vec<(String, String)>), dbus::Error> {
        self.method_call(
            "org.fcitx.Fcitx.Controller1",
            "InputMethodGroupInfo",
            (arg0,),
        )
    }

    fn input_method_groups(&self) -> Result<Vec<String>, dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "InputMethodGroups", ())
            .and_then(|r: (Vec<String>,)| Ok(r.0))
    }

    fn open_wayland_connection(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call(
            "org.fcitx.Fcitx.Controller1",
            "OpenWaylandConnection",
            (arg0,),
        )
    }

    fn open_wayland_connection_socket(&self, arg0: arg::OwnedFd) -> Result<(), dbus::Error> {
        self.method_call(
            "org.fcitx.Fcitx.Controller1",
            "OpenWaylandConnectionSocket",
            (arg0,),
        )
    }

    fn open_x11_connection(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "OpenX11Connection", (arg0,))
    }

    fn refresh(&self) -> Result<(), dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "Refresh", ())
    }

    fn reload_addon_config(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "ReloadAddonConfig", (arg0,))
    }

    fn reload_config(&self) -> Result<(), dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "ReloadConfig", ())
    }

    fn remove_input_method_group(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call(
            "org.fcitx.Fcitx.Controller1",
            "RemoveInputMethodGroup",
            (arg0,),
        )
    }

    fn reopen_wayland_connection_socket(
        &self,
        arg0: &str,
        arg1: arg::OwnedFd,
    ) -> Result<(), dbus::Error> {
        self.method_call(
            "org.fcitx.Fcitx.Controller1",
            "ReopenWaylandConnectionSocket",
            (arg0, arg1),
        )
    }

    fn reset_imlist(&self) -> Result<(), dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "ResetIMList", ())
    }

    fn restart(&self) -> Result<(), dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "Restart", ())
    }

    fn save(&self) -> Result<(), dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "Save", ())
    }

    fn set_addons_state(&self, arg0: Vec<(&str, bool)>) -> Result<(), dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "SetAddonsState", (arg0,))
    }

    fn set_config<I1: arg::Arg + arg::Append>(
        &self,
        arg0: &str,
        arg1: I1,
    ) -> Result<(), dbus::Error> {
        self.method_call(
            "org.fcitx.Fcitx.Controller1",
            "SetConfig",
            (arg0, arg::Variant(arg1)),
        )
    }

    fn set_current_im(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "SetCurrentIM", (arg0,))
    }

    fn set_input_method_group_info(
        &self,
        arg0: &str,
        arg1: &str,
        arg2: Vec<(&str, &str)>,
    ) -> Result<(), dbus::Error> {
        self.method_call(
            "org.fcitx.Fcitx.Controller1",
            "SetInputMethodGroupInfo",
            (arg0, arg1, arg2),
        )
    }

    fn set_log_rule(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "SetLogRule", (arg0,))
    }

    fn state(&self) -> Result<i32, dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "State", ())
            .and_then(|r: (i32,)| Ok(r.0))
    }

    fn switch_input_method_group(&self, arg0: &str) -> Result<(), dbus::Error> {
        self.method_call(
            "org.fcitx.Fcitx.Controller1",
            "SwitchInputMethodGroup",
            (arg0,),
        )
    }

    fn toggle(&self) -> Result<(), dbus::Error> {
        self.method_call("org.fcitx.Fcitx.Controller1", "Toggle", ())
    }
}
